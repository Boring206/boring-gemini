# 為什麼選擇 Boring？工具對比分析

> 了解 Boring 與 Cursor、Claude Code 及其他 AI 編碼助手有何不同。

---

## 📊 功能對比表

| 功能 | Cursor / Copilot | Claude Code | **Boring for Gemini** |
|------|------------------|-------------|-----------------------|
| **核心工作流** | 手動編輯與審核 | 命令行代理 (Agent) | **自主循環 (Autonomous Loop)** |
| **驗證機制** | 仰賴人工反饋 | 基礎指令執行 | **嚴格品質閘道 (Quality Gates)** |
| **規格驅動** | 基於單次提示詞 | 基於單次提示詞 | **規格驅動 (PRD/Task 對齊)** |
| **學習記憶** | 使用者對話歷史 | 會話上下文 | **跨會話模式學習 (Patterns)** |
| **安全防護** | 擴充功能權限 | Shell 存取權限 | **影子模式攔截 (Shadow Mode)** |

---

## 💎 Boring 的三大核心支柱

### 1. 100% 品質閘道 (Quality Gates)
當其他工具產生的代碼只是「看起來正確」時，Boring 會在合併前強制執行本地品質標準。它會不斷迭代，直到通過您的 Linter (`ruff`, `eslint`) 和測試 (`pytest`)。它不只是寫代碼，它確保代碼 **真的能跑**。

### 2. 規格驅動的一致性 (Spec-Driven)
Boring 以您的 PRD 和任務清單作為單一事實來源。它會對齊具體需求追蹤進度，確保沒有遺漏任何邊界情況，並保證最終實作符合當初的技術計畫。

### 3. 持續進化的智慧 (Learned Memory)
Boring 會捕捉「修復模式 (Fix Patterns)」。如果它在您的技術棧中遇到棘手的環境問題或隱蔽的 Bug，它會將解決方案儲存在 `.boring/brain` 中。下次遇到類似問題，它能立即解決，不再浪費 Token 重新思考。

---

## 🎯 該如何選擇？

- **使用 Cursor/Copilot**：進行快速的自動補全或以 UI 為中心的代碼探索。
- **使用 Claude Code**：處理快速的終端檔案操作或標準工程任務。
- **使用 Boring**：處理複雜功能實作、大規模重構，以及需要維持高可靠性的生產環境代碼——在這些場景中，「通過測試」是不可妥協的要求。
